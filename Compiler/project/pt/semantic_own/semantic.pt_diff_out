63,146c63,141
<         { Semantic Operations }
<         oSymbolTblEnter = 14;
<         oSymbolTblUpdate = 15;
<         oSymbolTblPushScope = 16;
<         oSymbolTblPopScope = 17;
<         oSymbolTblStripScope = 18;
<         oSymbolTblMergeScope = 19;
<         oSymbolTblSearchConvertFunctionReturnType = 20;
<         oSymbolTblChooseCurrentScopeIsFunction = 21; { >>14 }
<         oSymbolTblLookupExternal = 22; { >>14 }
<         oSymbolStkPush = 23; { (17) }
<         oSymbolStkPushIdentifier = 24;
<         oSymbolStkPushLocalIdentifier = 25;
<         oSymbolStkPushStandardVariable = 26; { (19) }
<         oSymbolStkPushFormalParameter = 27;
<         oSymbolStkSetKind = 28; { (17) }
<         oSymbolStkLinkToStandardType = 29; { (16) }
<         oSymbolStkEnterValue = 30;
<         oSymbolStkEnterStringValue = 31;
<         oSymbolStkEnterCodeAddress = 32;
<         oSymbolStkEnterDataAddress = 33;
<         oSymbolStkEnterTypeReference = 34;
<         oSymbolStkChooseKind = 35; { >>17 }
<         oSymbolStkChooseStandardFile = 36; { >>19 }
<         oSymbolStkChooseStandardRoutine = 37; { >>18 }
<         oSymbolStkPop = 38;
<         oTypeTblEnter = 39;
<         oTypeTblUpdate = 40;
<         oTypeStkPush = 41; { (20) }
<         oTypeStkPushSymbol = 42;
<         oTypeStkPushComponent = 43;
<         oTypeStkSetKind = 44; { (20) }
<         oTypeStkSetRecursionFlag = 45; { (14) }
<         oTypeStkChooseRecursionFlag = 46; { >>14 }
<         oTypeStkSetPackedComponentFlag = 47; { (14) }
<         oTypeStkChoosePackedComponentFlag = 48; { >>14 }
<         oTypeStkLinkToStandardComponentType = 49; { (16) }
<         oTypeStkEnterBounds = 50;
<         oTypeStkVerifyBounds = 51; { >>14 }
<         oTypeStkEnterParameterCount = 52;
<         oTypeStkCompareParameterCount = 53; { >>14 }
<         oTypeStkEnterComponentReference = 54;
<         oTypeStkChooseKind = 55; { >>20 }
<         oTypeStkChooseTypeReference = 56; { >>14 }
<         oTypeStkCompareNames = 57; { >>14 }
<         oTypeStkSwap = 58;
<         oTypeStkPop = 59;
<         oTypeStkPopAndCopyKind = 60;
<         oEmitNullAddress = 61;
<         oEmitValue = 62;
<         oEmitString = 63;
<         oEmitDataAddress = 64;
<         oEmitTrapKind = 65; { (21) }
<         oEmitCaseBranchTable = 66;
<         oAllocateAlignOnWord = 67;
<         oAllocateVariable = 68;
<         oAllocateVarParameter = 69;
<         oAllocateDescriptor = 70;
<         oValuePush = 71; { (13) }
<         oValuePushInteger = 72;
<         oValuePushStringLength = 73;
<         oValuePushSymbol = 74;
<         oValuePushCount = 75;
<         oValuePushTypeStkLowerBound = 76;
<         oValuePushTypeStkUpperBound = 77;
<         oValueNegate = 78;
<         oValueChoose = 79; { >>13 }
<         oValuePop = 80;
<         oCasePushDisplay = 81;
<         oCasePopDisplay = 82;
<         oCaseLookupLabel = 83; { >>14 }
<         oCasePushLabel = 84;
<         oCountPush = 85; { (13) }
<         oCountPushValue = 86;
<         oCountPop = 87;
<         oCountIncrement = 88;
<         oCountDecrement = 89;
<         oCountChoose = 90; { >>13 }
<         oFixPushForwardBranch = 91;
<         oFixPopForwardBranch = 92;
<         oFixPushTargetAddress = 93;
<         oFixPopTargetAddress = 94;
<         oFixPopAndEnterValue = 95;
<         oFixSwap = 96;
---
> 	{ Semantic Operations }
> 	oSymbolTblEnter = 14;
> 	oSymbolTblUpdate = 15;
> 	oSymbolTblPushScope = 16;
> 	oSymbolTblPopScope = 17;
> 	oSymbolTblLookupExternal = 18; { >>14 }
> 	oSymbolStkPush = 19; { (17) }
> 	oSymbolStkPushIdentifier = 20;
> 	oSymbolStkPushLocalIdentifier = 21;
> 	oSymbolStkPushStandardVariable = 22; { (19) }
> 	oSymbolStkPushFormalParameter = 23;
> 	oSymbolStkSetKind = 24; { (17) }
> 	oSymbolStkLinkToStandardType = 25; { (16) }
> 	oSymbolStkEnterValue = 26;
> 	oSymbolStkEnterStringValue = 27;
> 	oSymbolStkEnterCodeAddress = 28;
> 	oSymbolStkEnterDataAddress = 29;
> 	oSymbolStkEnterTypeReference = 30;
> 	oSymbolStkChooseKind = 31; { >>17 }
> 	oSymbolStkChooseStandardFile = 32; { >>19 }
> 	oSymbolStkChooseStandardRoutine = 33; { >>18 }
> 	oSymbolStkPop = 34;
> 	oTypeTblEnter = 35;
> 	oTypeTblUpdate = 36;
> 	oTypeStkPush = 37; { (20) }
> 	oTypeStkPushSymbol = 38;
> 	oTypeStkPushComponent = 39;
> 	oTypeStkSetKind = 40; { (20) }
> 	oTypeStkSetRecursionFlag = 41; { (14) }
> 	oTypeStkChooseRecursionFlag = 42; { >>14 }
> 	oTypeStkSetPackedComponentFlag = 43; { (14) }
> 	oTypeStkChoosePackedComponentFlag = 44; { >>14 }
> 	oTypeStkLinkToStandardComponentType = 45; { (16) }
> 	oTypeStkEnterBounds = 46;
> 	oTypeStkVerifyBounds = 47; { >>14 }
> 	oTypeStkEnterParameterCount = 48;
> 	oTypeStkCompareParameterCount = 49; { >>14 }
> 	oTypeStkEnterComponentReference = 50;
> 	oTypeStkChooseKind = 51; { >>20 }
> 	oTypeStkChooseTypeReference = 52; { >>14 }
> 	oTypeStkCompareNames = 53; { >>14 }
> 	oTypeStkSwap = 54;
> 	oTypeStkPop = 55;
> 	oEmitNullAddress = 56;
> 	oEmitValue = 57;
> 	oEmitString = 58;
> 	oEmitDataAddress = 59;
> 	oEmitTrapKind = 60; { (21) }
> 	oEmitCaseBranchTable = 61;
> 	oAllocateAlignOnWord = 62;
> 	oAllocateVariable = 63;
> 	oAllocateVarParameter = 64;
> 	oAllocateDescriptor = 65;
> 	oValuePush = 66; { (13) }
> 	oValuePushInteger = 67;
> 	oValuePushStringLength = 68;
> 	oValuePushSymbol = 69;
> 	oValuePushCount = 70;
> 	oValuePushTypeStkLowerBound = 71;
> 	oValuePushTypeStkUpperBound = 72;
> 	oValueNegate = 73;
> 	oValueChoose = 74; { >>13 }
> 	oValuePop = 75;
> 	oCasePushDisplay = 76;
> 	oCasePopDisplay = 77;
> 	oCaseLookupLabel = 78; { >>14 }
> 	oCasePushLabel = 79;
> 	oCountPush = 80; { (13) }
> 	oCountPushValue = 81;
> 	oCountPop = 82;
> 	oCountIncrement = 83;
> 	oCountDecrement = 84;
> 	oCountChoose = 85; { >>13 }
> 	oFixPushForwardBranch = 86;
> 	oFixPopForwardBranch = 87;
> 	oFixPushTargetAddress = 88;
> 	oFixPopTargetAddress = 89;
> 	oFixPopAndEnterValue = 90;
> 	oFixSwap = 91;
149,208c144,195
<         sIdentifier = 0;
<         firstSemanticToken = 0;
<         firstCompoundSemanticToken = 0;
<         sInteger = 1;
<         sLiteral = 2;
<         lastCompoundSemanticToken = 2;
<         sProgram = 3;
<         sParmBegin = 4;
<         sParmEnd = 5;
<         sConst = 6;
<         sType = 7;
<         sVar = 8;
<         sProcedure = 9;
<         sPublic = 10;
<         sBegin = 11;
<         sEnd = 12;
<         sNegate = 13;
<         sArray = 14;
<         sPacked = 15;
<         sFile = 16;
<         sRange = 17;
<         sCaseStmt = 18;
<         sDefault = 19;
<         sCaseEnd = 20;
<         sLabelEnd = 21;
<         sExpnEnd = 22;
<         sNullStmt = 23;
<         sAssignmentStmt = 24;
<         sSubscript = 25;
<         sCallStmt = 26;
<         sFieldWidth = 27;
<         sIfStmt = 28;
<         sThen = 29;
<         sElse = 30;
<         sClass = 31;
<         sLoopStmt = 32;
<         sLoopBreakWhen = 33;
<         sLoopEnd = 34;
<         sReturn = 35;
<         sEq = 36;
<         sNE = 37;
<         sLT = 38;
<         sLE = 39;
<         sGT = 40;
<         sGE = 41;
<         sAdd = 42;
<         sSubtract = 43;
<         sMultiply = 44;
<         sDivide = 45;
<         sModulus = 46;
<         sInfixOr = 47;
<         sOr = 48;
<         sInfixAnd = 49;
<         sAnd = 50;
<         sNot = 51;
<         sSubstring = 52;
<         sLength = 53;
<         sNewLine = 54;
<         sEndOfFile = 55;
<         lastSemanticToken = 55;
---
> 	sIdentifier = 0;
> 	firstInputToken = 0;
> 	sInteger = 1;
> 	sLiteral = 2;
> 	sProgram = 3;
> 	sParmBegin = 4;
> 	sParmEnd = 5;
> 	sConst = 6;
> 	sType = 7;
> 	sVar = 8;
> 	sProcedure = 9;
> 	sBegin = 10;
> 	sEnd = 11;
> 	sNegate = 12;
> 	sArray = 13;
> 	sPacked = 14;
> 	sFile = 15;
> 	sRange = 16;
> 	sCaseStmt = 17;
> 	sCaseEnd = 18;
> 	sLabelEnd = 19;
> 	sExpnEnd = 20;
> 	sNullStmt = 21;
> 	sAssignmentStmt = 22;
> 	sSubscript = 23;
> 	sCallStmt = 24;
> 	sFieldWidth = 25;
> 	sIfStmt = 26;
> 	sThen = 27;
> 	sElse = 28;
> 	sWhileStmt = 29;
> 	sRepeatStmt = 30;
> 	sRepeatEnd = 31;
> 	sEq = 32;
> 	sNE = 33;
> 	sLT = 34;
> 	sLE = 35;
> 	sGT = 36;
> 	sGE = 37;
> 	sAdd = 38;
> 	sSubtract = 39;
> 	sMultiply = 40;
> 	sDivide = 41;
> 	sModulus = 42;
> 	sInfixOr = 43;
> 	sOr = 44;
> 	sInfixAnd = 45;
> 	sAnd = 46;
> 	sNot = 47;
> 	sNewLine = 48;
> 	sEndOfFile = 49;
> 	lastInputToken = 49;
216,291c203,277
<  	tConcatenate = 4;
<         tSubtract = 5;
<         tEQ = 6;
<         tNE = 7;
<         tGT = 8;
<         tGE = 9;
<         tLT = 10;
<         tLE = 11;
<         tAnd = 12;
<         tInfixAnd = 13;
<         tOr = 14;
<         tInfixOr = 15;
<         tNegate = 16;
<         tNot = 17;
<         tChr = 18;
<         tOrd = 19;
<         tEoln = 20;
<         tEOF = 21;
<         tVarParm = 22;
<         tFetchAddress = 23;
<         tFetchInteger = 24;
<         tFetchString = 25;
<         tFetchBoolean = 26;
<         tAssignBegin = 27;
<         tAssignAddress = 28;
<         tAssignInteger = 29;
<         tAssignString = 30;
< 	tAssignBoolean = 31;
<         tStoreParmAddress = 32;
<         tStoreParmInteger = 33;
<         tStoreParmString = 34;
<         tStoreParmBoolean = 35;
<         tSubscriptBegin = 36;
<         tSubscriptAddress = 37;
<         tSubscriptInteger = 38;
<         tSubscriptString = 39;
<         tSubscriptBoolean = 40;
<         tArrayDescriptor = 41;
<         tFileDescriptor = 42;
<         tIfBegin = 43;
<         tIfEnd = 44;
<         tCaseBegin = 45;
<         tCallBegin = 46;
<         tParmEnd = 47;
<         tProcedureEnd = 48;
<         tWriteBegin = 49;
<         tReadBegin = 50;
<         tTrapBegin = 51;
<         tWriteEnd = 52;
<         tReadEnd = 53;
<         tFunctionResult = 54;
<         tLoopBegin = 55;
<         tLoopBreakWhen = 56;
<         tLoopTest = 57;
<         tLoopEnd = 58;
<         tCaseElse = 59;
< 	tSubstring = 60;
<         tLength = 61;
<         tStringEqual = 62;
<         tLiteralAddress = 63;
<         firstCompoundOutputToken = 63;
<         tLiteralInteger = 64;
< 	tLiteralBoolean = 65;
<         tLiteralString = 66;
<         tIfThen = 67;
<         tIfMerge = 68;
<         tCaseSelect = 69;
<         tCaseMerge = 70;
<         tCaseEnd = 71;
<         tSkipProc = 72;
<         tCallEnd = 73;
<         tLineNumber = 74;
<         tTrap = 75;
<         lastCompoundOutputToken = 75;
<         tEndOfFile = 76;
<         lastOutputToken = 76;
---
> 	tSubtract = 4;
> 	tEQ = 5;
> 	tNE = 6;
> 	tGT = 7;
> 	tGE = 8;
> 	tLT = 9;
> 	tLE = 10;
> 	tAnd = 11;
> 	tInfixAnd = 12;
> 	tOr = 13;
> 	tInfixOr = 14;
> 	tNegate = 15;
> 	tNot = 16;
> 	tChr = 17;
> 	tOrd = 18;
> 	tEoln = 19;
> 	tEOF = 20;
> 	tVarParm = 21;
> 	tFetchAddress = 22;
> 	tFetchInteger = 23;
> 	tFetchChar = 24;
> 	tFetchBoolean = 25;
> 	tAssignBegin = 26;
> 	tAssignAddress = 27;
> 	tAssignInteger = 28;
> 	tAssignChar = 29;
> 	tAssignBoolean = 30;
> 	tStoreParmAddress = 31;
> 	tStoreParmInteger = 32;
> 	tStoreParmChar = 33;
> 	tStoreParmBoolean = 34;
> 	tSubscriptBegin = 35;
> 	tSubscriptAddress = 36;
> 	tSubscriptInteger = 37;
> 	tSubscriptChar = 38;
> 	tSubscriptBoolean = 39;
> 	tArrayDescriptor = 40;
> 	tFileDescriptor = 41;
> 	tIfBegin = 42;
> 	tIfEnd = 43;
> 	tCaseBegin = 44;
> 	tWhileBegin = 45;
> 	tRepeatBegin = 46;
> 	tRepeatControl = 47;
> 	tCallBegin = 48;
> 	tParmEnd = 49;
> 	tProcedureEnd = 50;
> 	tWriteBegin = 51;
> 	tReadBegin = 52;
> 	tTrapBegin = 53;
> 	tWriteEnd = 54;
> 	tReadEnd = 55;
> 	tLiteralAddress = 56;
> 	firstCompoundOutputToken = 56;
> 	tLiteralInteger = 57;
> 	tLiteralChar = 58;
> 	tLiteralBoolean = 59;
> 	tLiteralString = 60;
> 	tStringDescriptor = 61;
> 	tSkipString = 62;
> 	tIfThen = 63;
> 	tIfMerge = 64;
> 	tCaseSelect = 65;
> 	tCaseMerge = 66;
> 	tCaseEnd = 67;
> 	tWhileTest = 68;
> 	tWhileEnd = 69;
> 	tRepeatTest = 70;
> 	tSkipProc = 71;
> 	tCallEnd = 72;
> 	tLineNumber = 73;
> 	tTrap = 74;
> 	lastCompoundOutputToken = 74;
> 	tEndOfFile = 75;
> 	lastOutputToken = 75;
322c308
< 	eStringExpnReqd = 35;
---
> 	eCharExpnReqd = 35;
332c318
< 	eStringFileVarReqd = 45;
---
> 	eCharFileVarReqd = 45;
346d331
< 	stringSize = 1024;
354c339
< 	pidString = 2;
---
> 	pidChar = 2;
378,380c363
< 	{MPM: 4th March, Change stdChar into stdString}
< 	{stdChar = 1;}
< 	stdString = 1;
---
> 	stdChar = 1;
390,395c373,375
<         syClass = 6;
<         syPublicProcedure = 7;
<         syPublicFunction = 8;
<         syExternal = 9;
<         syExpression = 10;
<         syUndefined = 11;
---
> 	syExternal = 6;
> 	syExpression = 7;
> 	syUndefined = 8;
415,416c395
< 	{tpChar = 1;}
< 	tpString = 1;
---
> 	tpChar = 1;
431,435c410,415
< 	trWriteInteger = 7;
< 	trReadInteger = 8;
< 	trAssign = 9;
< 	trWriteString = 107;
< 	trReadString = 108;
---
> 	trWriteString = 7;
> 	trWriteInteger = 8;
> 	trWriteChar = 9;
> 	trReadInteger = 10;
> 	trReadChar = 11;
> 	trAssign = 12;
438,508c418,483
<         Program = 0;
<         ProgramParameter = 41;
<         Block = 101;
<         AllocateVar = 892;
<         ProcedureDefinition = 1015;
<         ClassDefinition = 970;
<         ConstantDefinitions = 152;
<         TypeDefinitions = 315;
<         VariableDeclarations = 736;
<         BeginStmt = 1419;
<         ReturnStmt = 1941;
<         ConstantValue = 166;
<         SymbolStkPushIntegerConstant = 4441;
<         SymbolStkPushStringConstant = 4453;
<         TypeBody = 392;
<         OneTypePerLine = 356;
<         IndexType = 469;
<         ComponentType = 515;
<         SimpleType = 564;
<         ValuePushValuePlusOne = 4432;
<         SymbolStkPushIntegerType = 4465;
<         SubrangeUpperBound = 674;
<         VariableAttributes = 750;
<         ProcedureHeading = 1078;
<         ProcedureParameterType = 1169;
<         ProcedurePrologue = 1240;
<         FunctionHeaderReturnType = 1126;
<         CountCopy = 4437;
<         Statement = 1309;
<         AssignmentStmt = 1357;
<         CallStmt = 1433;
<         IfStmt = 1721;
<         LoopStmt = 1752;
<         CaseStmt = 1777;
<         Variable = 2604;
<         Expression = 1950;
<         CompareAndSwapTypes = 2443;
<         OpenProcedure = 3043;
<         AssignProcedure = 3112;
<         WriteProcedure = 3276;
<         WritelnProcedure = 3816;
<         ReadProcedure = 3928;
<         ReadlnProcedure = 4290;
<         ActualParameters = 1591;
<         FlushActuals = 4505;
<         VariableActual = 1659;
<         BooleanControlExpression = 4417;
<         CaseSelectorExpression = 4400;
<         CaseAlternative = 1837;
<         CompareReturnTypes = 2362;
<         Operand = 1980;
<         UnaryOperator = 2115;
<         BinaryOperator = 2155;
<         TernaryOperator = 2314;
<         FlushExpn = 4484;
<         ConstantOperand = 2738;
<         VariableOperand = 2772;
<         FunctionOperand = 2799;
<         SymbolStkPushIntegerVariable = 4472;
<         FileOperand = 3018;
<         CompareOperandAndResultTypes = 2543;
<         CompareRelationalOperandTypes = 2554;
<         VariableExtension = 2646;
<         StandardFunctionActual = 2923;
<         WriteString = 3608;
<         WriteNonString = 3732;
<         WriteStandardExpnList = 3541;
<         ReadStringParameterList = 4058;
<         ReadNonStringParameterList = 4124;
<         ReadString = 4190;
<         ReadNonString = 4219;
---
> 	Program = 0;
> 	ProgramParameter = 41;
> 	Block = 101;
> 	AllocateVar = 878;
> 	ProcedureDefinition = 956;
> 	ConstantDefinitions = 137;
> 	TypeDefinitions = 305;
> 	VariableDeclarations = 722;
> 	BeginStmt = 1311;
> 	ConstantValue = 151;
> 	SymbolStkPushIntegerConstant = 4122;
> 	SymbolStkPushCharConstant = 4134;
> 	TypeBody = 378;
> 	IndexType = 455;
> 	ComponentType = 501;
> 	SimpleType = 550;
> 	ValuePushValuePlusOne = 4113;
> 	SymbolStkPushIntegerType = 4146;
> 	SubrangeUpperBound = 660;
> 	VariableAttributes = 736;
> 	ProcedureHeading = 1009;
> 	ProcedureParameterType = 1055;
> 	ProcedurePrologue = 1126;
> 	CountCopy = 4118;
> 	Statement = 1195;
> 	AssignmentStmt = 1249;
> 	CallStmt = 1325;
> 	IfStmt = 1588;
> 	WhileStmt = 1619;
> 	CaseStmt = 1660;
> 	RepeatStmt = 1636;
> 	Variable = 2306;
> 	Expression = 1810;
> 	CompareAndSwapTypes = 2145;
> 	OpenProcedure = 2726;
> 	AssignProcedure = 2795;
> 	WriteProcedure = 2959;
> 	WritelnProcedure = 3497;
> 	ReadProcedure = 3609;
> 	ReadlnProcedure = 3971;
> 	ActualParameters = 1458;
> 	FlushActuals = 4186;
> 	VariableActual = 1526;
> 	BooleanControlExpression = 4098;
> 	CaseSelectorExpression = 4081;
> 	CaseAlternative = 1706;
> 	Operand = 1838;
> 	UnaryOperator = 1975;
> 	BinaryOperator = 2004;
> 	FlushExpn = 4165;
> 	ConstantOperand = 2440;
> 	VariableOperand = 2476;
> 	FunctionOperand = 2503;
> 	SymbolStkPushIntegerVariable = 4153;
> 	FileOperand = 2701;
> 	CompareOperandAndResultTypes = 2245;
> 	CompareRelationalOperandTypes = 2256;
> 	VariableExtension = 2348;
> 	StandardFunctionActual = 2606;
> 	WriteChar = 3289;
> 	WriteNonChar = 3413;
> 	WriteStandardExpnList = 3222;
> 	ReadCharParameterList = 3739;
> 	ReadNonCharParameterList = 3805;
> 	ReadChar = 3871;
> 	ReadNonChar = 3900;
512c487
< 	sslTblSize = 4524;
---
> 	sslTblSize = 4205;
642,643c617
< {%%%%%%%% MJM 29Feb16: changed from 'Input' to 'Semantic' to match all other files }
< 	InputTokens = firstSemanticToken .. lastSemanticToken;
---
> 	InputTokens = firstInputToken .. lastInputToken;
835,836c809
< 	{MPM 5th March: Change standardCharTypeRef into standardStringTypeRef}
< 	standardStringTypeRef :  TypeTblReference;
---
> 	standardCharTypeRef :  TypeTblReference;
954,960c927,931
< 	    {MPM 12th March: change pidChar type into pidString type}
< 	    { String }
< 	    symbolTblKind[pidString] := syType;
< 	    symbolTblTypeTblLink[pidString] := pidString;
< 	    typeTblKind[pidString] := tpString;
< 	    {MPM 5th March: Change standardCharTypeRef into standardStringTypeRef}
< 	    standardStringTypeRef := pidString;
---
> 	    { char }
> 	    symbolTblKind[pidChar] := syType;
> 	    symbolTblTypeTblLink[pidChar] := pidChar;
> 	    typeTblKind[pidChar] := tpChar;
> 	    standardCharTypeRef := pidChar;
972,973c943
< 	    {MPM 5th March: Change standardCharTypeRef into standardStringTypeRef}
< 	    typeTblComponentLink[pidText] := standardStringTypeRef;
---
> 	    typeTblComponentLink[pidText] := standardCharTypeRef;
1111,1112c1081,1082
< 		eStringExpnReqd:
< 		    write('string type expression required');
---
> 		eCharExpnReqd:
> 		    write('char type expression required');
1133c1103
< 		eStringFileVarReqd:
---
> 		eCharFileVarReqd:
1764,1880d1733
< {%%%%%%%% MJM 1Mar16: Added 'oSymbolTblStripScope' and 'oSymbolTblMergeScope'
< %%%%%%%%%             to handle "popping" the Symbol table scope properly
< %%%%%%%%%             after a 'class' declaration. To do this, both operations
< %%%%%%%%%             need to be called in sequence instead of oSymbolTblPopScope
< %%%%%%%%%             at the end of the 'class' rule.  This is done to make the 
< %%%%%%%%%             symbols inside the class invisible, however, the public
< %%%%%%%%%             functions/procedures remain visible.
< %%%%%%%%}
<                     oSymbolTblStripScope:
<                         { Strips the top level of the symbol stack by setting
<                           the identSymbolTbl references to the entries in the
<                           symbolTbl at the next lower Lexical Level.  }
<                         { Notice that this is only done for non-Public entries, 
<                           which will be dealt with with the oSymbolMergeScope
<                           Operation that gets called after this for classes.  }
< 
<                         begin
<                             Assert((lexicLevelStackTop >= 1), assert31);
<                             i := symbolTblTop;
<                             j := symbolTblDisplay[lexicLevelStackTop];
< 
< 
<                             { Set the identifier table pointer to the identifier
<                               entry in the closest enclosing scope if there is 
<                               one AND only if it is a non-Public kind}
<                             while i > j do
<                                 begin
<                                     link := symbolTblIdentLink[i];
< 
<                                     if link <> null then
<                                         { This is not a dummy identifier
<                                           generated by the parser's syntax
<                                           error recovery procedure.       }
<                                         begin
<                                             while link > 0 do
<                                                 link := symbolTblIdentLink[link];
<                                         if symbolTblKind[i] <> syPublicProcedure then
<                                             identSymbolTblRef[-link] :=
<                                                 symbolTblIdentLink[i];
<                                         end;
< 
<                                     i := i - 1
<                                 end;
< 
<                         end;
< 
< {%%%%%%%% MJM 1Mar16: Added 'oSymbolTblMergeScope' as per comment block above}
<                     oSymbolTblMergeScope:
<                         { This merges the top two scopes in the symbol table 
<                           by decrementing the lexical level but not changing the 
<                           symbol table top. If this was called immediately after 
<                           oSymbolTblStripScope (which it should be), then only the 
<                           public procedures from the top scope will be visible, 
<                           and only they will be merged. 
<                         { We are doing this so that the Public procedures will 
<                           become visible to the enclosing Class scope or Main 
<                           program scope. }
< 
<                         begin
<                             { Decrement the Lexical Levl}
<                             lexicLevelStackTop := lexicLevelStackTop - 1;
<                         end;
< 
< 
< {%%%%%%%% MJM 7Mar16: Added 'oSymbolTblSearchConvertFunctionReturnType' }
<                     oSymbolTblSearchConvertFunctionReturnType:
< {%%%%%%%% MJM 7Mar16: This traverses the top scope in the symbol table 
< %%%%%%%%              until it finds the 'syProcedure' or 'syPublicProcedure'
< %%%%%%%%              kind, and then sets it to 'syFunction' or 
< %%%%%%%%              'syPublicFuntion'. 
< %%%%%%%%}
<                         begin
<                             Assert((lexicLevelStackTop >= 1), assert31);
<                             i := symbolTblTop;
<                             j := symbolTblDisplay[lexicLevelStackTop];
< 
<                 {%%%%%%% MJM 10Mar16: do scope traversal to get to procedure
<                 %%%%%%%%              entry, which really should always
< 		%%%%%%%%              be at the bottom of the
<                 %%%%%%%%              scope on the symbolTble, i.e. at
<                 %%%%%%%%              symbolTblDisplay[lexicLevelStackTop]
<                 %%%%%%%}
< 
<                             while i >= j do
<                                 begin
<                                     if symbolTblKind[i] = syPublicProcedure then
<                                         symbolTblKind[i] := syPublicFunction;
<                                     if symbolTblKind[i] = syProcedure then
<                                         symbolTblKind[i] := syFunction;
< 
<                                     i := i - 1
<                                 end
< 
<                         end;
< 
< 
< {%%%%%%% MJM 7Mar16: Added 'oSymbolTblChooseCurrentScopeIsFunction' }
<                     oSymbolTblChooseCurrentScopeIsFunction:
< {%%%%%%% MJM 7Mar16: If this is a function, then the bottom of the scope
< %%%%%%%%              in the table should be the 'syFunction' or 
< %%%%%%%%              'syPublicFunction' kind.
< %%%%%%%%              Return true/yes if the scope is a function
< %%%%%%%%              and false/no otherwise.
< %%%%%%%%}
<                         begin
<                             resultValue := no;
<                             Assert((lexicLevelStackTop >= 1), assert31);
<                             i := symbolTblTop;
<                             j := symbolTblDisplay[lexicLevelStackTop];
<                         if( (symbolTblKind[j] = syFunction)
<                          or (symbolTblKind[j] = syPublicFunction) ) then
<                             resultValue := yes
<                         end;
< 
< 
< {%%%%%%%%}
< 
2004,2009c1857,1858
< {%%%%%%%% MJM 4Mar16: Add assertion case to handle syPublicProcedure }
<                             Assert(((symbolStkKind[symbolStkTop] = syProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syFunction)
<                                 or (symbolStkKind[symbolStkTop] = syPublicProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syPublicFunction)),
<                                         assert24);
---
> 			    Assert((symbolStkKind[symbolStkTop] =
> 				syProcedure), assert24);
2025,2026c1874
< 			    {MPM: 4th March, Change stdChar into stdString}
< 			    stdString:
---
> 			    stdChar:
2028,2029c1876
< 					{MPM 5th March: Change standardCharTypeRef into standardStringTypeRef}
< 					standardStringTypeRef;
---
> 					standardCharTypeRef;
2201,2202c2048
< 				{MPM: 4th March, Change stdChar into stdString}
< 				stdString:
---
> 				stdChar:
2204,2205c2050
< 					{MPM 5th March: Change standardCharTypeRef into standardStringTypeRef}
< 					standardStringTypeRef;
---
> 					standardCharTypeRef;
2236,2240c2081
< {%%%%%%%% MJM 4Mar16: Add assertion case to handle syPublicProcedure }
<                             Assert(((symbolStkKind[symbolStkTop] = syProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syFunction)
<                                 or (symbolStkKind[symbolStkTop] = syPublicProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syPublicFunction)),
---
> 			    Assert((symbolStkKind[symbolStkTop] = syProcedure),
2250,2254c2091
< {%%%%%%%% MJM 4Mar16: Add assertion case to handle syPublicProcedure }
<                             Assert(((symbolStkKind[symbolStkTop] = syProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syFunction)
<                                 or (symbolStkKind[symbolStkTop] = syPublicProcedure)
<                                 or (symbolStkKind[symbolStkTop] = syPublicFunction)),
---
> 			    Assert((symbolStkKind[symbolStkTop] = syProcedure),
2323,2335d2159
< {%%%%%%%% MJM 10Mar16: Add new semantic mechanism to support 'function':
< %%%%%%%%%              This copies the Kind from the top entry in the
< %%%%%%%%%              type stack into the next lower stack entry,
< %%%%%%%%%              then pops the stack.
< %%%%%%%%}
<                     oTypeStkPopAndCopyKind:
<                         begin
<                             Assert((typeStkTop > 0), assert17);
<                             typeStkKind[ typeStkTop -1 ] := typeStkKind[ typeStkTop];
<                             typeStkTop := typeStkTop -1;
<                         end;
< 
< 
2549c2373
< 			    tpBoolean:
---
> 			    tpChar, tpBoolean:
2551,2553d2374
< 			    {MPM 5th March: Add handing allocation of Strings}
< 			    tpString:
< 				dataAreaEnd := dataAreaEnd + stringSize;
